\documentclass{article}

\input{../../packages.tex}

\graphicspath{ {../Images/} }

\begin{document}
    \begin{titlepage}
        \begin{center}

        Міністерство освіти і науки України
        
        НТУУ «Київський політехнічний інститут»
        
        Фізико-технічний інститут
        \vspace{3.3cm}
        
        {\textbf{Проектування високонавантажених систем}\\Лабораторна робота No5\\Робота з базовими функціями БД типу column family на прикладі Cassandra}

        \vspace{10cm}

        \begin{flushright}
            \textbf{Виконав:}\\Студент 4-го курсу\\групи ФІ-21\\Климентьєв Максим\\
            \textbf{Перевірив:}\\\text{\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_}
        \end{flushright}

        \end{center}
    \end{titlepage}
    \newpage

    \pagenumbering{gobble}
    \tableofcontents
    \cleardoublepage
    \pagenumbering{arabic}
    \setcounter{page}{3}

    \newpage
    \section{Код реалізації}
    % \lstinputlisting[language=sql, title=task_1.py]{../task_1.py}
    % \lstinputlisting[language=sql, title=task_2.py]{../task_2.py}
    % \lstinputlisting[language=sql, title=task_3.py]{../task_3.py}

    \newpage
    \section{Результати}
        \subsection{Частина 1. Робота зі структурами даних у Cassandra}
            Створіть keyspace з найпростішої стратегією реплікації
                \begin{lstlisting}[language=sql]
CREATE KEYSPACE shop 
WITH replication = {'class': 'SimpleStrategy', 'replication_factor': 1};
                \end{lstlisting}
            В цьому keyspace необхідно буде створити дві таблиці: items та orders
            Таблиця items містить різноманітні товари (тобто у яких різний набір властивостей).

            Для набору властивостей товару виберіть базові характеристики однакові для всіх товарів (name, category, price, producer, ...),
            а для властивостей які відрізняються використовуйте тип map (створивши індекс для можливості пошуку по її вмісту)

            Увага: Необхідно, щоб пошук швидко працював для категорії (category) товарів. Ця вимога має бути врахована при створенні ключа для таблиці (тобто, category має бути partition key).
                \begin{lstlisting}[language=sql]
CREATE TABLE items (
    id uuid,
    name text,
    producer text,
    category text,
    price decimal,
    features map<text, text>,
    PRIMARY KEY ((category), price, id)
);
CREATE INDEX items_features_index ON items(ENTRIES(features));
                \end{lstlisting}

            Наповніть таблиці тестовими данними
            \begin{figure}[ht]
                \includegraphics[width=1\linewidth]{task_1_test_data.png}
            \end{figure}

            !!! У запитах заборонено використовувати ALLOW FILTERING !!!
            \begin{enumerate}
                \item Напишіть запит, який показує структуру створеної таблиці (команда DESCRIBE)
                    \begin{lstlisting}[language=sql]
DESCRIBE TABLE items;
                    \end{lstlisting}
                    \begin{lstlisting}[language=sql]
CREATE TABLE shop.items (
    category text,
    price decimal,
    id uuid,
    name text,
    producer text,
    features map<text, text>,
    PRIMARY KEY (category, price, id)
) WITH CLUSTERING ORDER BY (price ASC, id ASC)
    AND additional_write_policy = '99p'
    AND allow_auto_snapshot = true
    AND bloom_filter_fp_chance = 0.01
    AND caching = {'keys': 'ALL', 'rows_per_partition': 'NONE'}
    AND cdc = false
    AND comment = ''
    AND compaction = {'class': 'org.apache.cassandra.db.compaction.SizeTieredCompactionStrategy', 'max_threshold': '32', 'min_threshold': '4'}
    AND compression = {'chunk_length_in_kb': '16', 'class': 'org.apache.cassandra.io.compress.LZ4Compressor'}
    AND memtable = 'default'
    AND crc_check_chance = 1.0
    AND default_time_to_live = 0
    AND extensions = {}
    AND gc_grace_seconds = 864000
    AND incremental_backups = true
    AND max_index_interval = 2048
    AND memtable_flush_period_in_ms = 0
    AND min_index_interval = 128
    AND read_repair = 'BLOCKING'
    AND speculative_retry = '99p';

CREATE INDEX items_features_index ON shop.items (entries(features));

CREATE INDEX items_name_index ON shop.items (name);

CREATE MATERIALIZED VIEW shop.items_by_producer AS
    SELECT category, producer, price, id, features, name
    FROM shop.items
    WHERE category IS NOT NULL AND producer IS NOT NULL AND price IS NOT NULL AND id IS NOT NULL
    PRIMARY KEY (category, producer, price, id)
 WITH CLUSTERING ORDER BY (producer ASC, price ASC, id ASC)
    AND additional_write_policy = '99p'
    AND allow_auto_snapshot = true
    AND bloom_filter_fp_chance = 0.01
    AND caching = {'keys': 'ALL', 'rows_per_partition': 'NONE'}
    AND cdc = false
    AND comment = ''
    AND compaction = {'class': 'org.apache.cassandra.db.compaction.SizeTieredCompactionStrategy', 'max_threshold': '32', 'min_threshold': '4'}
    AND compression = {'chunk_length_in_kb': '16', 'class': 'org.apache.cassandra.io.compress.LZ4Compressor'}
    AND memtable = 'default'
    AND crc_check_chance = 1.0
    AND extensions = {}
    AND gc_grace_seconds = 864000
    AND incremental_backups = true
    AND max_index_interval = 2048
    AND memtable_flush_period_in_ms = 0
    AND min_index_interval = 128
    AND read_repair = 'BLOCKING'
    AND speculative_retry = '99p';
                    \end{lstlisting}
                \item Напишіть запит, який виводить усі товари в певній категорії відсортовані за ціною
                    \begin{lstlisting}[language=sql]
select * from items where category = 'Настільні ігри';
                    \end{lstlisting}
                    \begin{figure}[ht]
                        \centering
                        \includegraphics[width=1\linewidth]{task_1_select_category.png}
                    \end{figure}\newpage
                \item Напишіть запити, які вибирають товари за різними критеріями в межах певної категорії (тут де треба замість індексу використайте Matirialized view):
                    \begin{itemize}
                        \item назва,
                        \item ціна (в проміжку),
                        \item ціна та виробник
                    \end{itemize}
                    \begin{lstlisting}[language=sql]
CREATE INDEX items_name_index ON items(name);

CREATE MATERIALIZED VIEW items_by_producer AS
SELECT category, producer, price, id, name, features
FROM items
WHERE category IS NOT NULL AND producer IS NOT NULL AND price IS NOT NULL AND id IS NOT NULL
PRIMARY KEY ((category), producer, price, id);

SELECT * FROM items WHERE name = 'UNO Cards';
SELECT * FROM items WHERE category = 'Настільні ігри' AND price >= 500 AND price <= 1000;
SELECT * FROM items_by_producer WHERE category = 'Настільні ігри' AND producer = 'Hasbro' AND price >= 500 AND price <= 3000;
                    \end{lstlisting}
                    \begin{figure}[ht]
                        \includegraphics[width=1\linewidth]{task_1_select_name.png}
                    \end{figure}
                    \begin{figure}[ht]
                        \includegraphics[width=1\linewidth]{task_1_select_price.png}
                    \end{figure}
                    \begin{figure}[ht]
                        \includegraphics[width=1\linewidth]{task_1_select_producer_and_price.png}
                    \end{figure}
            \end{enumerate}\newpage

            Створіть таблицю orders в якій міститься ім'я замовника і інформація про замовлення: перелік id-товарів у замовленні, вартість замовлення, дата замовлення, ....

            Для кожного замовника повинна бути можливість швидко шукати його замовлення і виконувати по них запити.
            Ця вимога має бути врахована при створенні ключа для таблиці (аналогічно як для items).
            \begin{lstlisting}[language=sql]
CREATE TABLE orders (
    customer_name text,
    order_time timestamp,
    order_id uuid,
    item_ids list<uuid>,
    total_price decimal,
    PRIMARY KEY ((customer_name), order_time, order_id)
) WITH CLUSTERING ORDER BY (order_time DESC);

CREATE INDEX orders_item_ids_index ON orders(item_ids);
CREATE INDEX orders_total_price_index ON orders(total_price);
            \end{lstlisting}            
            \begin{enumerate}
                \item Напишіть запит, який показує структуру створеної таблиці (команда DESCRIBE)
                    \begin{lstlisting}[language=sql]
DESCRIBE TABLE orders;
                    \end{lstlisting}
                    \begin{lstlisting}[language=sql]
CREATE TABLE shop.orders (
    customer_name text,
    order_time timestamp,
    order_id uuid,
    total_price decimal,
    item_ids list<uuid>,
    PRIMARY KEY (customer_name, order_time, order_id)
) WITH CLUSTERING ORDER BY (order_time DESC, order_id ASC)
    AND additional_write_policy = '99p'
    AND allow_auto_snapshot = true
    AND bloom_filter_fp_chance = 0.01
    AND caching = {'keys': 'ALL', 'rows_per_partition': 'NONE'}
    AND cdc = false
    AND comment = ''
    AND compaction = {'class': 'org.apache.cassandra.db.compaction.SizeTieredCompactionStrategy', 'max_threshold': '32', 'min_threshold': '4'}
    AND compression = {'chunk_length_in_kb': '16', 'class': 'org.apache.cassandra.io.compress.LZ4Compressor'}
    AND memtable = 'default'
    AND crc_check_chance = 1.0
    AND default_time_to_live = 0
    AND extensions = {}
    AND gc_grace_seconds = 864000
    AND incremental_backups = true
    AND max_index_interval = 2048
    AND memtable_flush_period_in_ms = 0
    AND min_index_interval = 128
    AND read_repair = 'BLOCKING'
    AND speculative_retry = '99p';

CREATE INDEX orders_item_ids_index ON shop.orders (values(item_ids));

CREATE INDEX orders_total_price_index ON shop.orders (total_price);
                    \end{lstlisting}
                \item Для замовника виведіть всі його замовлення відсортовані за часом коли вони були зроблені
                    \begin{lstlisting}[language=sql]
EXPAND ON;
select * from orders where customer_name = 'Andriy';
EXPAND OFF;
select * from orders where customer_name = 'Andriy';
                    \end{lstlisting}
                    \begin{figure}[ht]
                        \includegraphics[width=0.5\linewidth]{task_1_select_customer_name_v.png}
                    \end{figure}
                    \begin{figure}[ht]
                        \includegraphics[width=1\linewidth]{task_1_select_customer_name_h.png}
                    \end{figure}
                \item Для кожного замовників підрахуйте загальну суму на яку були зроблені усі його замовлення
                    \begin{lstlisting}[language=sql]
select customer_name, sum(total_price) as all_price from orders GROUP BY customer_name;
                    \end{lstlisting}
                    \begin{figure}[ht]
                        \centering
                        \includegraphics[width=1\linewidth]{task_1_select_name_total_price.png}
                    \end{figure}\newpage
                \item Для кожного замовлення виведіть час коли його ціна були занесена в базу (SELECT WRITETIME)
                    \begin{lstlisting}[language=sql]
SELECT customer_name, order_time, order_id, total_price, WRITETIME(total_price) as write_time FROM orders;
                    \end{lstlisting}
                    \begin{figure}[ht]
                        \centering
                        \includegraphics[width=1\linewidth]{task_1_select_order_by_writetime.png}
                    \end{figure}
            \end{enumerate}

        \newpage
        \subsection{Частина 2. Налаштування реплікації у Cassandra}

        \begin{enumerate}
            \item Сконфігурувати кластер з 3-х нод:
                \lstinputlisting[style=yaml, title=docker-compose.yml]{../docker-compose.yml}
            \item Перевірити правильність конфігурації за допомогою nodetool status
                \begin{lstlisting}[language=sql]
docker exec -it cassandra-node1 nodetool status
                \end{lstlisting}
                \begin{lstlisting}[style=hazellog, language=sql]
Datacenter: dc1
===============
Status=Up/Down
|/ State=Normal/Leaving/Joining/Moving
--  Address     Load       Tokens  Owns (effective)  Host ID                               Rack
UN  172.18.0.3  85.22 KiB   16      72.2%             6eec0752-ea2d-423c-ba6d-83211e6a73c5  rack1
UN  172.18.0.2  194.38 KiB  16      59.3%             4f7f8a4c-893e-4815-bee1-da6090b8a56c  rack1
UN  172.18.0.4  80.09 KiB   16      68.5%             34511972-165a-4c27-8448-9f92768af587  rack1
                \end{lstlisting}
            \item Викоритовуючи cqlsh, створити три Keyspace з replication factor 1, 2, 3 з SimpleStrategy
                \begin{lstlisting}[language=sql]
CREATE KEYSPACE shop_rf1 
WITH replication = {'class': 'SimpleStrategy', 'replication_factor': 1};

CREATE KEYSPACE shop_rf2 
WITH replication = {'class': 'SimpleStrategy', 'replication_factor': 2};

CREATE KEYSPACE shop_rf3 
WITH replication = {'class': 'SimpleStrategy', 'replication_factor': 3};
                \end{lstlisting}
            \item В кожному з кейспейсів створити прості таблиці
                \begin{lstlisting}[language=sql]
CREATE TABLE shop_rf1.items (id int PRIMARY KEY, name text);

CREATE TABLE shop_rf2.items (id int PRIMARY KEY, name text);

CREATE TABLE shop_rf3.items (id int PRIMARY KEY, name text);
                \end{lstlisting}
        \end{enumerate}

        \begin{enumerate}
            \item Спробуйте писати і читати в ці таблиці підключаюсь до різних нод через cqlsh.
                \begin{lstlisting}[language=sql]
INSERT INTO shop_rf1.items (id, name) VALUES (1, 'Item One');
INSERT INTO shop_rf2.items (id, name) VALUES (1, 'Item One');
INSERT INTO shop_rf3.items (id, name) VALUES (1, 'Item One');
SELECT * FROM shop_rf1.items;
SELECT * FROM shop_rf2.items;
SELECT * FROM shop_rf3.items;

docker exec -it cassandra-node1 cqlsh cassandra-node1 -f /scripts/task_2.cql
                \end{lstlisting}
            \item Вставте дані в створені таблиці і подивіться на їх розподіл по вузлах кластера окремо для кожного з кейспесов (команда nodetool status) - має бути видно відсоток даних який зберігається на ноді
                \begin{lstlisting}[language=sql]
docker exec -it cassandra-node1 nodetool status shop_rf1
docker exec -it cassandra-node1 nodetool status shop_rf2
docker exec -it cassandra-node1 nodetool status shop_rf3
                \end{lstlisting}
                \begin{lstlisting}[language=sql]
Datacenter: dc1
===============
Status=Up/Down
|/ State=Normal/Leaving/Joining/Moving
--  Address     Load        Tokens  Owns (effective)  Host ID                               Rack
UN  172.18.0.3  86.01 KiB  16      30.3%             6eec0752-ea2d-423c-ba6d-83211e6a73c5  rack1
UN  172.18.0.2  80.09 KiB  16      40.3%             4f7f8a4c-893e-4815-bee1-da6090b8a56c  rack1
UN  172.18.0.4  80.09 KiB  16      29.4%             34511972-165a-4c27-8448-9f92768af587  rack1

Datacenter: dc1
===============
Status=Up/Down
|/ State=Normal/Leaving/Joining/Moving
--  Address     Load        Tokens  Owns (effective)  Host ID                               Rack
UN  172.18.0.3  86.01 KiB  16      72.2%             6eec0752-ea2d-423c-ba6d-83211e6a73c5  rack1
UN  172.18.0.2  80.09 KiB  16      59.3%             4f7f8a4c-893e-4815-bee1-da6090b8a56c  rack1
UN  172.18.0.4  80.09 KiB  16      68.5%             34511972-165a-4c27-8448-9f92768af587  rack1

Datacenter: dc1
===============
Status=Up/Down
|/ State=Normal/Leaving/Joining/Moving
--  Address     Load        Tokens  Owns (effective)  Host ID                               Rack 
UN  172.18.0.3  86.01 KiB  16      100.0%            6eec0752-ea2d-423c-ba6d-83211e6a73c5  rack1
UN  172.18.0.2  80.09 KiB  16      100.0%            4f7f8a4c-893e-4815-bee1-da6090b8a56c  rack1
UN  172.18.0.4  80.09 KiB  16      100.0%            34511972-165a-4c27-8448-9f92768af587  rack1
                \end{lstlisting}
            \item Для якогось запису з кожного з кейспейсу виведіть ноди на яких зберігаються дані - має бути видно ip-адреси вузлів на яких зберігається даний рядок
                \begin{lstlisting}[language=sql]
docker exec -it cassandra-node1 nodetool getendpoints shop_rf1 items 1
docker exec -it cassandra-node1 nodetool getendpoints shop_rf2 items 1
docker exec -it cassandra-node1 nodetool getendpoints shop_rf3 items 1
                \end{lstlisting}
                \begin{lstlisting}[language=sql]
172.18.0.2

172.18.0.2
172.18.0.4

172.18.0.2
172.18.0.4
172.18.0.3
                \end{lstlisting}
            \end{enumerate}

        \begin{enumerate}
            \item Відключити одну з нод. Для кожного з кейспейсів перевірити з якими рівнями consistency можемо читати та писати
                \begin{lstlisting}[language=sql]
docker stop cassandra-node3
docker exec -it cassandra-node1 cqlsh
                \end{lstlisting}
                \begin{itemize}
                    \item для Keyspace з replication factor 1 - CONSISTENCY ONE
                        \begin{lstlisting}[language=sql]
USE shop_rf1;
CONSISTENCY ONE;
INSERT INTO items (id, name) VALUES (100, 'Risky Data');
                        \end{lstlisting}
                        \begin{lstlisting}[language=sql]
NoHostAvailable: ('Unable to complete the operation against any hosts', {<Host: 127.0.0.1:9042 dc1>: Unavailable('Error from server: code=1000 [Unavailable exception] message="Cannot achieve consistency level ONE" info={\'consistency\': \'ONE\', \'required_replicas\': 1, \'alive_replicas\': 0}')})
                        \end{lstlisting}
                    \item для Keyspace з replication factor 2 - CONSISTENCY ONE/TWO
                        \begin{lstlisting}[language=sql]
USE shop_rf2;
CONSISTENCY ONE;
INSERT INTO items (id, name) VALUES (200, 'Risky Data');
select * from items;

CONSISTENCY TWO;
INSERT INTO items (id, name) VALUES (201, 'Risky Data 2');
                        \end{lstlisting}
                        \begin{lstlisting}[language=sql]
 id  | name
-----+------------
   1 |   Item One
 200 | Risky Data

NoHostAvailable: ('Unable to complete the operation against any hosts', {<Host: 127.0.0.1:9042 dc1>: Unavailable('Error from server: code=1000 [Unavailable exception] message="Cannot achieve consistency level TWO" info={\'consistency\': \'TWO\', \'required_replicas\': 2, \'alive_replicas\': 1}')})
                        \end{lstlisting}
                    \item для Keyspace з replication factor 3 - CONSISTENCY ONE/TWO/THREE
                        \begin{lstlisting}[language=sql]
USE shop_rf3;
CONSISTENCY ONE;
INSERT INTO items (id, name) VALUES (300, 'Risky Data');
select * from items;

CONSISTENCY TWO;
INSERT INTO items (id, name) VALUES (301, 'Risky Data 2');
select * from items;

CONSISTENCY THREE;
INSERT INTO items (id, name) VALUES (302, 'Risky Data 2');
                        \end{lstlisting}
                        \begin{lstlisting}[language=sql]
 id  | name
-----+------------
   1 |   Item One
 300 | Risky Data

 id  | name
-----+--------------
   1 |     Item One
 300 |   Risky Data
 301 | Risky Data 2

NoHostAvailable: ('Unable to complete the operation against any hosts', {<Host: 127.0.0.1:9042 dc1>: Unavailable('Error from server: code=1000 [Unavailable exception] message="Cannot achieve consistency level THREE" info={\'consistency\': \'THREE\', \'required_replicas\': 3, \'alive_replicas\': 2}')})
                        \end{lstlisting}
                \end{itemize}
        \end{enumerate}

        \begin{enumerate}
            \item Зробить так щоб три ноди працювали, але не бачили одна одну по мережі (заблокуйте чи відключити зв'язок між ними)
                \begin{lstlisting}[language=sql]
docker start cassandra-node3
docker network disconnect lab5_cassandra-net cassandra-node1
docker network disconnect lab5_cassandra-net cassandra-node2
docker network disconnect lab5_cassandra-net cassandra-node3
                \end{lstlisting}
            \item Для кейспейсу з replication factor 3 задайте рівень consistency рівним 1.
                Виконайте по черзі запис значення з однаковим primary key, але різними іншими значенням окремо на кожну з нод (тобто створіть конфлікт)
                \begin{lstlisting}[language=sql]
docker exec -it cassandra-node1 cqlsh -e "USE shop_rf3; CONSISTENCY ONE; INSERT INTO items (id, name) VALUES (777, 'ISLAND_1');"
docker exec -it cassandra-node2 cqlsh -e "USE shop_rf3; CONSISTENCY ONE; INSERT INTO items (id, name) VALUES (777, 'ISLAND_2');"
docker exec -it cassandra-node3 cqlsh -e "USE shop_rf3; CONSISTENCY ONE; INSERT INTO items (id, name) VALUES (777, 'ISLAND_3');"
                \end{lstlisting}
            \item Відновіть зв'язок між нодами, і перевірте що вони знову об'єдналися у кластер.
                Визначте яким чином була вирішений конфлікт даних та яке значення було прийнято кластером та за яким принципом
                \begin{lstlisting}[language=sql]
docker network connect lab5_cassandra-net cassandra-node1
docker network connect lab5_cassandra-net cassandra-node2
docker network connect lab5_cassandra-net cassandra-node3

docker exec -it cassandra-node1 nodetool status

docker restart cassandra-node1 cassandra-node2 cassandra-node3

docker exec -it cassandra-node1 nodetool status

docker exec -it cassandra-node1 cqlsh -e "SELECT id, name, WRITETIME(name) FROM shop_rf3.items WHERE id = 777;"
                \end{lstlisting}
                \begin{lstlisting}[language=sql]
 id  | name     | writetime(name)
-----+----------+------------------
 777 | ISLAND_3 | 1765903107702957
                \end{lstlisting}
        \end{enumerate}

    \subsection{Частина 3. Аналіз продуктивності та перевірка цілісності}

        Аналогічно попереднім завданням, необхідно, для кластеру налаштованому у попередній частині, створити таблицю з каунтером лайків.
        Далі з 10 окремих клієнтів одночасно запустити інкерементацію каунтеру лайків по 10\_000 на кожного клієнта з різними опціями взаємодії з Cassandra.

        Таблиця має бути створена у Keyspace з replication factor 3.
                \begin{lstlisting}[language=sql]

                \end{lstlisting}

        Для створення каунтеру використовуйте спеціальний тип колонки - counter (цей тип буде підтримувати операції increment/decrement in-place):

        \begin{enumerate}
            \item Вказавши у параметрах запиту Consistency Level One (це буде означати, що запис відбувається синхронно тільки на одну ноду),
                запустіть 10 клієнтів з інкрементом по 10\_000 на кожному з них.
                Виміряйте час виконання та перевірте чи кінцеве значення буде дорівнювати очікуваному - 100К
                \begin{lstlisting}[language=sql]

                \end{lstlisting}
            \item Вказавши у параметрах запиту Consistency Level QUORUM (це буде означати, що запис відбувається синхронно на більшість нод),
                запустіть 10 клієнтів з інкрементом по 10\_000 на кожному з них.
                Виміряйте час виконання та перевірте чи кінцеве значення буде дорівнювати очікуваному - 100К
                \begin{lstlisting}[language=sql]

                \end{lstlisting}
        \end{enumerate}

\end{document}