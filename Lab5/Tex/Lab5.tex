\documentclass{article}

\input{../../packages.tex}

\graphicspath{ {../Images/} }

\begin{document}
    \begin{titlepage}
        \begin{center}

        Міністерство освіти і науки України
        
        НТУУ «Київський політехнічний інститут»
        
        Фізико-технічний інститут
        \vspace{3.3cm}
        
        {\textbf{Проектування високонавантажених систем}\\Лабораторна робота No5\\Робота з базовими функціями БД типу column family на прикладі Cassandra}

        \vspace{10cm}

        \begin{flushright}
            \textbf{Виконав:}\\Студент 4-го курсу\\групи ФІ-21\\Климентьєв Максим\\
            \textbf{Перевірив:}\\\text{\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_}
        \end{flushright}

        \end{center}
    \end{titlepage}
    \newpage

    \pagenumbering{gobble}
    \tableofcontents
    \cleardoublepage
    \pagenumbering{arabic}
    \setcounter{page}{3}

    \newpage
    \section{Код реалізації}
    % \lstinputlisting[language=python]{../task_1.py}
    % \lstinputlisting[language=python]{../task_2.py}
    % \lstinputlisting[language=python]{../task_3.py}

    \newpage
    \section{Результати}
        \subsection{Частина 1. Робота зі структурами даних у Cassandra}
            Створіть keyspace з найпростішої стратегією реплікації
                \begin{lstlisting}[language=python]

                \end{lstlisting}
            В цьому keyspace необхідно буде створити дві таблиці: items та orders
            Таблиця items містить різноманітні товари (тобто у яких різний набір властивостей).
                \begin{lstlisting}[language=python]

                \end{lstlisting}

            Для набору властивостей товару виберіть базові характеристики однакові для всіх товарів (name, category, price, producer, ...),
            а для властивостей які відрізняються використовуйте тип map (створивши індекс для можливості пошуку по її вмісту)
                \begin{lstlisting}[language=python]

                \end{lstlisting}

            Увага: Необхідно, щоб пошук швидко працював для категорії (category) товарів. Ця вимога має бути врахована при створенні ключа для таблиці (тобто, category має бути partition key).
                \begin{lstlisting}[language=python]

                \end{lstlisting}

            Наповніть таблиці тестовими данними
                \begin{lstlisting}[language=python]

                \end{lstlisting}

            !!! У запитах заборонено використовувати ALLOW FILTERING !!!
            \begin{enumerate}
                \item Напишіть запит, який показує структуру створеної таблиці (команда DESCRIBE)
                    \begin{lstlisting}[language=python]

                    \end{lstlisting}
                \item Напишіть запит, який виводить усі товари в певній категорії відсортовані за ціною
                    \begin{lstlisting}[language=python]

                    \end{lstlisting}
                \item Напишіть запити, які вибирають товари за різними критеріями в межах певної категорії (тут де треба замість індексу використайте Matirialized view):
                    \begin{itemize}
                        \item назва,
                        \item ціна (в проміжку),
                        \item ціна та виробник
                    \end{itemize}
                    \begin{lstlisting}[language=python]

                    \end{lstlisting}
            \end{enumerate}

            Створіть таблицю orders в якій міститься ім'я замовника і інформація про замовлення: перелік id-товарів у замовленні, вартість замовлення, дата замовлення, ....
                \begin{lstlisting}[language=python]

                \end{lstlisting}

            Для кожного замовника повинна бути можливість швидко шукати його замовлення і виконувати по них запити.
            Ця вимога має бути врахована при створенні ключа для таблиці (аналогічно як для items).
            \begin{lstlisting}[language=python]

            \end{lstlisting}
            
            \begin{enumerate}
                \item Напишіть запит, який показує структуру створеної таблиці (команда DESCRIBE)
                    \begin{lstlisting}[language=python]

                    \end{lstlisting}
                \item Для замовника виведіть всі його замовлення відсортовані за часом коли вони були зроблені
                    \begin{lstlisting}[language=python]

                    \end{lstlisting}
                \item Для кожного замовників підрахуйте загальну суму на яку були зроблені усі його замовлення
                    \begin{lstlisting}[language=python]

                    \end{lstlisting}
                \item Для кожного замовлення виведіть час коли його ціна були занесена в базу (SELECT WRITETIME)
                    \begin{lstlisting}[language=python]

                    \end{lstlisting}
            \end{enumerate}

    \subsection{Частина 2. Налаштування реплікації у Cassandra}

        \begin{enumerate}
            \item Сконфігурувати кластер з 3-х нод:
                \begin{lstlisting}[language=python]

                \end{lstlisting}
            \item Перевірити правильність конфігурації за допомогою nodetool status
                \begin{lstlisting}[language=python]

                \end{lstlisting}
            \item Викоритовуючи cqlsh, створити три Keyspace з replication factor 1, 2, 3 з SimpleStrategy
                \begin{lstlisting}[language=python]

                \end{lstlisting}
            \item В кожному з кейспейсів створити прості таблиці
                \begin{lstlisting}[language=python]

                \end{lstlisting}
        \end{enumerate}

        \begin{enumerate}
            \item Спробуйте писати і читати в ці таблиці підключаюсь до різних нод через cqlsh.
                \begin{lstlisting}[language=python]

                \end{lstlisting}
            \item Вставте дані в створені таблиці і подивіться на їх розподіл по вузлах кластера окремо для кожного з кейспесов (команда nodetool status) - має бути видно відсоток даних який зберігається на ноді
                \begin{lstlisting}[language=python]

                \end{lstlisting}
            \item Для якогось запису з кожного з кейспейсу виведіть ноди на яких зберігаються дані - має бути видно ip-адреси вузлів на яких зберігається даний рядок
                \begin{lstlisting}[language=python]

                \end{lstlisting}
        \end{enumerate}

        \begin{enumerate}
            \item Відключити одну з нод. Для кожного з кейспейсів перевірити з якими рівнями consistency можемо читати та писати
                \begin{itemize}
                    \item для Keyspace з replication factor 1 - CONSISTENCY ONE
                        \begin{lstlisting}[language=python]

                        \end{lstlisting}
                    \item для Keyspace з replication factor 2 - CONSISTENCY ONE/TWO
                        \begin{lstlisting}[language=python]

                        \end{lstlisting}
                    \item для Keyspace з replication factor 3 - CONSISTENCY ONE/TWO/THREE
                        \begin{lstlisting}[language=python]

                        \end{lstlisting}
                \end{itemize}
        \end{enumerate}

        \begin{enumerate}
            \item Зробить так щоб три ноди працювали, але не бачили одна одну по мережі (заблокуйте чи відключити зв'язок між ними)
                \begin{lstlisting}[language=python]

                \end{lstlisting}
            \item Для кейспейсу з replication factor 3 задайте рівень consistency рівним 1.
                Виконайте по черзі запис значення з однаковим primary key, але різними іншими значенням окремо на кожну з нод (тобто створіть конфлікт)
                \begin{lstlisting}[language=python]

                \end{lstlisting}
            \item Відновіть зв'язок між нодами, і перевірте що вони знову об'єдналися у кластер.
                Визначте яким чином була вирішений конфлікт даних та яке значення було прийнято кластером та за яким принципом
                \begin{lstlisting}[language=python]

                \end{lstlisting}
        \end{enumerate}

    \subsection{Частина 3. Аналіз продуктивності та перевірка цілісності}

        Аналогічно попереднім завданням, необхідно, для кластеру налаштованому у попередній частині, створити таблицю з каунтером лайків.
        Далі з 10 окремих клієнтів одночасно запустити інкерементацію каунтеру лайків по 10\_000 на кожного клієнта з різними опціями взаємодії з Cassandra.

        Таблиця має бути створена у Keyspace з replication factor 3.
                \begin{lstlisting}[language=python]

                \end{lstlisting}

        Для створення каунтеру використовуйте спеціальний тип колонки - counter (цей тип буде підтримувати операції increment/decrement in-place):

        \begin{enumerate}
            \item Вказавши у параметрах запиту Consistency Level One (це буде означати, що запис відбувається синхронно тільки на одну ноду),
                запустіть 10 клієнтів з інкрементом по 10\_000 на кожному з них.
                Виміряйте час виконання та перевірте чи кінцеве значення буде дорівнювати очікуваному - 100К
                \begin{lstlisting}[language=python]

                \end{lstlisting}
            \item Вказавши у параметрах запиту Consistency Level QUORUM (це буде означати, що запис відбувається синхронно на більшість нод),
                запустіть 10 клієнтів з інкрементом по 10\_000 на кожному з них.
                Виміряйте час виконання та перевірте чи кінцеве значення буде дорівнювати очікуваному - 100К
                \begin{lstlisting}[language=python]

                \end{lstlisting}
        \end{enumerate}

\end{document}